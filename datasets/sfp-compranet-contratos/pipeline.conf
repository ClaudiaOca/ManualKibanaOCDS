#
# ENTRADA: Archivos CSV en /etc/logstash/input/sfp-compranet-contratos/
#
input {
  file {
    path => "/etc/datasets/sfp-compranet-contratos/input/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    ignore_older => 864000000
    close_older => 2
    max_open_files => 16
  }
}
#
# FILTROS
#
filter {
  # Procesa el archivo CSV, si hay errores agrega el tag "_csvparsefailure"
  csv {
    columns => [ "GOBIERNO","SIGLAS","DEPENDENCIA","CLAVEUC","NOMBRE_DE_LA_UC","RESPONSABLE","CODIGO_EXPEDIENTE","TITULO_EXPEDIENTE","PLANTILLA_EXPEDIENTE","NUMERO_PROCEDIMIENTO","EXP_F_FALLO","PROC_F_PUBLICACION","FECHA_APERTURA_PROPOSICIONES","CARACTER","TIPO_CONTRATACION","TIPO_PROCEDIMIENTO","FORMA_PROCEDIMIENTO","CODIGO_CONTRATO","TITULO_CONTRATO","FECHA_INICIO","FECHA_FIN","IMPORTE_CONTRATO","MONEDA","ESTATUS_CONTRATO","ARCHIVADO","CONVENIO_MODIFICATORIO","RAMO","CLAVE_PROGRAMA","APORTACION_FEDERAL","FECHA_CELEBRACION","CONTRATO_MARCO","IDENTIFICADOR_CM","COMPRA_CONSOLIDADA","PLURIANUAL","CLAVE_CARTERA_SHCP","ESTRATIFICACION_MUC","FOLIO_RUPC","PROVEEDOR_CONTRATISTA","ESTRATIFICACION_MPC","SIGLAS_PAIS","ESTATUS_EMPRESA","CUENTA_ADMINISTRADA_POR","C_EXTERNO","ORGANISMO","ANUNCIO" ]
    skip_header => true
  }
  # Cuenta columnas como validacion simple, 45 columnas de datos + 5 meta columnass, si hay error, agrega el tag "_csvparsefailure"
  ruby {
    code => "raise('error') unless event.to_hash.length == (45 + 5)"
    tag_on_exception => "_csvparsefailure"
  }
  # Si no hay error hasta ahora, continuamos con la transformacion de datos
  if "_csvparsefailure" not in [tags] {
    mutate {
      # Inicializa campo RAMO_POR_UC
      add_field => { "RAMO_POR_UC" => "" }
      # Limpia espacios
      strip => [ "GOBIERNO","SIGLAS","DEPENDENCIA","CLAVEUC","NOMBRE_DE_LA_UC","RESPONSABLE","CODIGO_EXPEDIENTE","TITULO_EXPEDIENTE","PLANTILLA_EXPEDIENTE","NUMERO_PROCEDIMIENTO","EXP_F_FALLO","PROC_F_PUBLICACION","FECHA_APERTURA_PROPOSICIONES","CARACTER","TIPO_CONTRATACION","TIPO_PROCEDIMIENTO","FORMA_PROCEDIMIENTO","CODIGO_CONTRATO","TITULO_CONTRATO","FECHA_INICIO","FECHA_FIN","IMPORTE_CONTRATO","MONEDA","ESTATUS_CONTRATO","ARCHIVADO","CONVENIO_MODIFICATORIO","RAMO","CLAVE_PROGRAMA","APORTACION_FEDERAL","FECHA_CELEBRACION","CONTRATO_MARCO","IDENTIFICADOR_CM","COMPRA_CONSOLIDADA","PLURIANUAL","CLAVE_CARTERA_SHCP","ESTRATIFICACION_MUC","FOLIO_RUPC","PROVEEDOR_CONTRATISTA","ESTRATIFICACION_MPC","SIGLAS_PAIS","ESTATUS_EMPRESA","CUENTA_ADMINISTRADA_POR","C_EXTERNO","ORGANISMO","ANUNCIO" ]
      # Cambia estos campos a minusculas
      lowercase => [ "ARCHIVADO", "CONVENIO_MODIFICATORIO", "CONTRATO_MARCO", "COMPRA_CONSOLIDADA", "PLURIANUAL", "C_EXTERNO" ]
      # La columna DEPENDENCIA es limpiada de guiones bajos
      gsub => [ "DEPENDENCIA", "_", "" ]
      # Agregamos el tag "_csvparsefailure", sera quitado en el siguiento filtro mutate->convert
      add_tag => [ "_csvparsefailure" ]
    }
    # Los campos booleans pueden contener la palabra "si", la reemplazamos por "true" (aceptado por ElasticSearch)
    if [ARCHIVADO] == "si" { mutate { update => { "ARCHIVADO" => "true" } } }
    if [C_EXTERNO] == "si" { mutate { update => { "C_EXTERNO" => "true" } } }
    if [COMPRA_CONSOLIDADA] == "si" { mutate { update => { "COMPRA_CONSOLIDADA" => "true" } } }
    if [CONTRATO_MARCO] == "si" { mutate { update => { "CONTRATO_MARCO" => "true" } } }
    if [CONVENIO_MODIFICATORIO] == "si" { mutate { update => { "CONVENIO_MODIFICATORIO" => "true" } } }
    if [PLURIANUAL] == "si" { mutate { update => { "PLURIANUAL" => "true" } } }
    # Los campos con tipo fijo son procesados, y en caso de exito, el tag "_csvparsefailure" es removido
    mutate {
      convert => {
        "ARCHIVADO" => "boolean"
        "C_EXTERNO" => "boolean"
        "COMPRA_CONSOLIDADA" => "boolean"
        "CONTRATO_MARCO" => "boolean"
        "CONVENIO_MODIFICATORIO" => "boolean"
        "IMPORTE_CONTRATO" => "float"
        "PLURIANUAL" => "boolean"
      }
      remove_tag => [ "_csvparsefailure" ]
    }
    # Las fechas son procesadas, algunos valores traen un timestamp incorrecto que es ignorado, todas las fechas son procesadas con timezone de Cd. Mexico
    date { target => "EXP_F_FALLO" match => ["EXP_F_FALLO", "yyyy-MM-dd", "yyyy-MM-dd' 00:00:00 GMT'"] timezone => "America/Mexico_City" }
    date { target => "PROC_F_PUBLICACION" match => ["PROC_F_PUBLICACION", "yyyy-MM-dd", "yyyy-MM-dd' 00:00:00 GMT'"] timezone => "America/Mexico_City" }
    date { target => "FECHA_APERTURA_PROPOSICIONES" match => ["FECHA_APERTURA_PROPOSICIONES", "yyyy-MM-dd", "yyyy-MM-dd' 00:00:00 GMT'"] timezone => "America/Mexico_City" }
    date { target => "FECHA_INICIO" match => ["FECHA_INICIO", "yyyy-MM-dd", "yyyy-MM-dd' 00:00:00 GMT'"] timezone => "America/Mexico_City" }
    date { target => "FECHA_FIN" match => ["FECHA_FIN", "yyyy-MM-dd", "yyyy-MM-dd' 00:00:00 GMT'"] timezone => "America/Mexico_City" }
    date { target => "FECHA_CELEBRACION" match => ["FECHA_CELEBRACION", "yyyy-MM-dd", "yyyy-MM-dd' 00:00:00 GMT'"] timezone => "America/Mexico_City" }
    # Extraemos el RAMO_POR_UC (ramo segun la clave de unidad), si no hay tal, se ignora
    grok {
      match => { "CLAVEUC" => "^0(?<RAMO_POR_UC>[0-9][0-9])" }
      overwrite => [ "RAMO_POR_UC" ]
      tag_on_failure => []
    }
    # Quitamos campos que no son necesarios
    mutate {
      remove_field => [ "path", "host" ]
    }
  }
}
#
# SALIDA
#
output {
  if "_csvparsefailure" in [tags] {
    # En caso de error de analisis o transformacion (tag "_csvparsefailure") agrega al log de failure
    file {
      path => "/etc/datasets/sfp-compranet-contratos/logs/failure.log"
      create_if_deleted => true
    }
  } else {
    # Si no hay error envia a un CSV nuevo, con los datos procesados y a ElasticSearch
    file {
      path => "/etc/datasets/sfp-compranet-contratos/logs/success.log"
      codec => line { format => "%{message}" }
      create_if_deleted => true
    }
    elasticsearch {
      index => "poder-sfp-compranet-contratos"
      hosts => [ "elasticsearch:9200" ]
      template => "/etc/datasets/sfp-compranet-contratos/template.json"
      template_name => "poder-sfp-compranet-contratos"
      template_overwrite => true
      document_id => "%{CODIGO_CONTRATO}"
      user => logstash_poder
      password => logstash
    }
  }
}
